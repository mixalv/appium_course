"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;
exports.getAndroidBinaryPath = getAndroidBinaryPath;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _semver = _interopRequireDefault(require("semver"));

let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const ADB_RETRY_ERROR_PATTERNS = [/protocol fault \(no status\)/i, /error: device ('.+' )?not found/i, /error: device still connecting/i];
const BINARY_VERSION_PATTERN = /^Version ([\d.]+)-(\d+)/m;
const BRIDGE_VERSION_PATTERN = /^Android Debug Bridge version ([\d.]+)/m;
const CERTS_ROOT = '/system/etc/security/cacerts';
const SDK_BINARY_ROOTS = ['platform-tools', 'emulator', ['cmdline-tools', 'latest', 'bin'], 'tools', ['tools', 'bin'], '.'];
const MIN_DELAY_ADB_API_LEVEL = 28;

systemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath(binaryName) {
  return await this.getBinaryFromSdkRoot(binaryName);
};

systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOSMemorize(binaryName) {
  return getBinaryNameForOS(binaryName);
});

function getBinaryNameForOS(binaryName) {
  if (!_support.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {
    return `${binaryName}.bat`;
  }

  if (!_path.default.extname(binaryName)) {
    return `${binaryName}.exe`;
  }

  return binaryName;
}

systemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);
  const binaryLocs = getSdkBinaryLocationCandidates(this.sdkRoot, fullBinaryName);
  let buildToolsDirs = await (0, _helpers.getBuildToolsDirs)(this.sdkRoot);

  if (this.buildToolsVersion) {
    buildToolsDirs = buildToolsDirs.filter(x => _path.default.basename(x) === this.buildToolsVersion);

    if (_lodash.default.isEmpty(buildToolsDirs)) {
      _logger.default.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);
    } else {
      _logger.default.info(`Using build tools at '${buildToolsDirs}'`);
    }
  }

  binaryLocs.push(..._lodash.default.flatten(buildToolsDirs.map(dir => [_path.default.resolve(dir, fullBinaryName), _path.default.resolve(dir, 'lib', fullBinaryName)])));
  let binaryLoc = null;

  for (const loc of binaryLocs) {
    if (await _support.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` + `installed at '${this.sdkRoot}'?`);
  }

  _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

  this.binaries[binaryName] = binaryLoc;
  return binaryLoc;
};

function getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName) {
  return SDK_BINARY_ROOTS.map(x => _path.default.resolve(sdkRoot, ...(_lodash.default.isArray(x) ? x : [x]), fullBinaryName));
}

async function getAndroidBinaryPath(binaryName) {
  const fullBinaryName = getBinaryNameForOS(binaryName);
  const sdkRoot = (0, _helpers.getSdkRootFromEnv)();
  const binaryLocs = getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName);

  for (const loc of binaryLocs) {
    if (await _support.fs.exists(loc)) {
      return loc;
    }
  }

  throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools installed at '${sdkRoot}'?`);
}

systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);

  try {
    const binaryLoc = await _support.fs.which(fullBinaryName);

    _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

    this.binaries[binaryName] = binaryLoc;
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` + `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function getConnectedDevices() {
  _logger.default.debug('Getting connected devices');

  let stdout;

  try {
    ({
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'devices']));
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }

  const listHeader = 'List of devices';
  const startingIndex = stdout.indexOf(listHeader);

  if (startingIndex < 0) {
    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);
  }

  stdout = stdout.slice(startingIndex);
  let excludedLines = [listHeader, 'adb server', '* daemon'];

  if (!this.allowOfflineDevices) {
    excludedLines.push('offline');
  }

  const devices = stdout.split('\n').map(_lodash.default.trim).filter(line => line && !excludedLines.some(x => line.includes(x))).reduce((acc, line) => {
    const [udid, state] = line.split(/\s+/);
    acc.push({
      udid,
      state
    });
    return acc;
  }, []);

  if (_lodash.default.isEmpty(devices)) {
    _logger.default.debug('No connected devices have been detected');
  } else {
    _logger.default.debug(`Connected devices: ${JSON.stringify(devices)}`);
  }

  return devices;
};

systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  const timer = new _support.timing.Timer().start();

  _logger.default.debug('Trying to find a connected android device');

  const getDevices = async () => {
    if (timer.getDuration().asMilliSeconds > timeoutMs) {
      throw new Error(`Could not find a connected Android device in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms.`);
    }

    try {
      const devices = await this.getConnectedDevices();

      if (devices.length > 0) {
        return devices;
      }
    } catch (ign) {}

    _logger.default.debug('Could not find online devices');

    try {
      await this.reconnect();
    } catch (ign) {
      await this.restartAdb();
    }

    await (0, _asyncbox.sleep)(200);
    return await getDevices();
  };

  return await getDevices();
};

systemCallMethods.reconnect = async function reconnect(target = 'offline') {
  _logger.default.debug(`Reconnecting adb (target ${target})`);

  const args = ['reconnect'];

  if (target) {
    args.push(target);
  }

  try {
    await this.adbExec(args);
  } catch (e) {
    throw new Error(`Cannot reconnect adb. Original error: ${e.stderr || e.message}`);
  }
};

systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
    await this.adbExec(['start-server']);
  } catch (e) {
    _logger.default.error(`Error killing ADB server, going to see if it's online anyway`);
  }
};

systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port '${this.adbPort}'`);

  await this.adbExec(['kill-server'], {
    exclusive: true
  });
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _support.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

let isExecLocked = false;
systemCallMethods.EXEC_OUTPUT_FORMAT = Object.freeze({
  STDOUT: 'stdout',
  FULL: 'full'
});

systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  const {
    outputFormat = this.EXEC_OUTPUT_FORMAT.STDOUT
  } = opts;
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = [...this.executable.defaultArgs, ...cmd];

      _logger.default.debug(`Running '${this.executable.path} ` + (args.find(arg => /\s+/.test(arg)) ? _support.util.quote(args) : args.join(' ')) + `'`);

      let {
        stdout,
        stderr
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return outputFormat === this.EXEC_OUTPUT_FORMAT.FULL ? {
        stdout,
        stderr
      } : stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;

      if (ADB_RETRY_ERROR_PATTERNS.some(p => p.test(errText))) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Command output: ${e.stderr || e.stdout || '<empty>'}`;
      }

      throw e;
    }
  };

  if (isExecLocked) {
    _logger.default.debug('Waiting until the other exclusive ADB command is completed');

    await (0, _asyncbox.waitForCondition)(() => !isExecLocked, {
      waitMs: Number.MAX_SAFE_INTEGER,
      intervalMs: 10
    });

    _logger.default.debug('Continuing with the current ADB command');
  }

  if (opts.exclusive) {
    isExecLocked = true;
  }

  try {
    return await execFunc();
  } finally {
    if (opts.exclusive) {
      isExecLocked = false;
    }
  }
};

systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged
  } = opts;
  const cmdArr = _lodash.default.isArray(cmd) ? cmd : [cmd];
  const fullCmd = ['shell'];

  if (privileged) {
    _logger.default.info(`'adb shell ${_support.util.quote(cmdArr)}' requires root access`);

    if (await this.isRoot()) {
      _logger.default.info('The device already had root access');

      fullCmd.push(...cmdArr);
    } else {
      fullCmd.push('su', 'root', _support.util.quote(cmdArr));
    }
  } else {
    fullCmd.push(...cmdArr);
  }

  return await this.adbExec(fullCmd, opts);
};

systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = [...this.executable.defaultArgs, ...args];

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function getConnectedEmulators() {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${_support.util.pluralize('emulator', emulators.length, true)} connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find '${avdName}' emulator`);

  try {
    const emulators = await this.getConnectedEmulators();

    for (const emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      const runningAVDName = await this.execEmuConsoleCommand(['avd', 'name'], {
        port: emulator.port,
        execTimeout: 5000,
        connTimeout: 1000
      });

      if (_lodash.default.toLower(avdName) === _lodash.default.toLower(runningAVDName.trim())) {
        _logger.default.debug(`Found emulator '${avdName}' on port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator '${avdName}' not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  try {
    return await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return await this.getRunningAVD(avdName.replace('@', ''));
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }
};

systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;

  if (_support.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_support.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _support.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function launchAVD(avdName, opts = {}) {
  const {
    args = [],
    env = {},
    language,
    country,
    launchTimeout = 60000,
    readyTimeout = 60000,
    retryTimes = 1
  } = opts;

  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${launchTimeout}ms and readyTimeout ${readyTimeout}ms`);

  const emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  const launchArgs = ['-avd', avdName];
  launchArgs.push(...(0, _helpers.toAvdLocaleArgs)(language, country));
  let isDelayAdbFeatureEnabled = false;

  if (this.allowDelayAdb) {
    const {
      revision
    } = await this.getEmuVersionInfo();

    if (revision && _support.util.compareVersions(revision, '>=', '29.0.7')) {
      try {
        const {
          target
        } = await this.getEmuImageProperties(avdName);
        const apiMatch = /\d+/.exec(target);

        if (apiMatch && parseInt(apiMatch[0], 10) >= MIN_DELAY_ADB_API_LEVEL) {
          launchArgs.push('-delay-adb');
          isDelayAdbFeatureEnabled = true;
        } else {
          throw new Error(`The actual image API version is below ${MIN_DELAY_ADB_API_LEVEL}`);
        }
      } catch (e) {
        _logger.default.info(`The -delay-adb emulator startup detection feature will not be enabled. ` + `Original error: ${e.message}`);
      }
    }
  } else {
    _logger.default.info('The -delay-adb emulator startup detection feature has been explicitly disabled');
  }

  if (!_lodash.default.isEmpty(args)) {
    launchArgs.push(...(_lodash.default.isArray(args) ? args : _support.util.shellParse(`${args}`)));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${_support.util.quote(launchArgs)}`);

  if (!_lodash.default.isEmpty(env)) {
    _logger.default.debug(`Customized emulator environment: ${JSON.stringify(env)}`);
  }

  const proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs, {
    env: Object.assign({}, process.env, env)
  });
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, launchTimeout));

  if (isDelayAdbFeatureEnabled) {
    try {
      await this.adbExec(['wait-for-device'], {
        timeout: readyTimeout
      });
    } catch (e) {
      throw new Error(`'${avdName}' Emulator has failed to boot: ${e.stderr || e.message}`);
    }
  } else {
    await this.waitForEmulatorReady(readyTimeout);
  }

  return proc;
};

systemCallMethods.getVersion = _lodash.default.memoize(async function getVersion() {
  let stdout;

  try {
    stdout = await this.adbExec('version');
  } catch (e) {
    throw new Error(`Error getting adb version: ${e.stderr || e.message}`);
  }

  const result = {};
  const binaryVersionMatch = BINARY_VERSION_PATTERN.exec(stdout);

  if (binaryVersionMatch) {
    result.binary = {
      version: _semver.default.coerce(binaryVersionMatch[1]),
      build: parseInt(binaryVersionMatch[2], 10)
    };
  }

  const bridgeVersionMatch = BRIDGE_VERSION_PATTERN.exec(stdout);

  if (bridgeVersionMatch) {
    result.bridge = {
      version: _semver.default.coerce(bridgeVersionMatch[1])
    };
  }

  return result;
});

systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test(await this.shell(['pm', 'get-install-location']));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) * 1000 / retries;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      try {
        await this.reconnect();
      } catch (ign) {
        await this.restartAdb();
      }

      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  const {
    wasAlreadyRooted
  } = await this.root();

  try {
    await this.shell(['stop']);
    await _bluebird.default.delay(2000);
    await this.setDeviceProperty('sys.boot_completed', 0, {
      privileged: false
    });
    await this.shell(['start']);
  } catch (e) {
    const {
      message
    } = e;

    if (message.includes('must be root')) {
      throw new Error(`Could not reboot device. Rebooting requires root access and ` + `attempt to get root access on device failed with error: '${message}'`);
    }

    throw e;
  } finally {
    if (!wasAlreadyRooted) {
      await this.unroot();
    }
  }

  const timer = new _support.timing.Timer().start();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.changeUserPrivileges = async function changeUserPrivileges(isElevated) {
  const cmd = isElevated ? 'root' : 'unroot';

  const retryIfOffline = async cmdFunc => {
    try {
      return await cmdFunc();
    } catch (err) {
      if (['closed', 'device offline', 'timeout expired'].some(x => (err.stderr || '').toLowerCase().includes(x))) {
        _logger.default.warn(`Attempt to ${cmd} caused ADB to think the device went offline`);

        try {
          await this.reconnect();
        } catch (ign) {
          await this.restartAdb();
        }

        return await cmdFunc();
      } else {
        throw err;
      }
    }
  };

  const isRoot = await retryIfOffline(async () => await this.isRoot());

  if (isRoot && isElevated || !isRoot && !isElevated) {
    return {
      isSuccessful: true,
      wasAlreadyRooted: isRoot
    };
  }

  let wasAlreadyRooted = isRoot;

  try {
    const {
      stdout
    } = await retryIfOffline(async () => await this.adbExec([cmd]));

    _logger.default.debug(stdout);

    if (stdout) {
      if (stdout.includes('adbd cannot run as root')) {
        return {
          isSuccessful: false,
          wasAlreadyRooted
        };
      }

      if (stdout.includes('already running as root')) {
        wasAlreadyRooted = true;
      }
    }

    return {
      isSuccessful: true,
      wasAlreadyRooted
    };
  } catch (err) {
    const {
      stderr = '',
      message
    } = err;

    _logger.default.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);

    return {
      isSuccessful: false,
      wasAlreadyRooted
    };
  }
};

systemCallMethods.root = async function root() {
  return await this.changeUserPrivileges(true);
};

systemCallMethods.unroot = async function unroot() {
  return await this.changeUserPrivileges(false);
};

systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function fileExists(remotePath) {
  const passFlag = '__PASS__';
  const checkCmd = `[ -e '${remotePath.replace(/'/g, `\\'`)}' ] && echo ${passFlag}`;

  try {
    return _lodash.default.includes(await this.shell([checkCmd]), passFlag);
  } catch (ign) {
    return false;
  }
};

systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _support.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _support.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _support.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _support.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _support.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIkFEQl9SRVRSWV9FUlJPUl9QQVRURVJOUyIsIkJJTkFSWV9WRVJTSU9OX1BBVFRFUk4iLCJCUklER0VfVkVSU0lPTl9QQVRURVJOIiwiQ0VSVFNfUk9PVCIsIlNES19CSU5BUllfUk9PVFMiLCJNSU5fREVMQVlfQURCX0FQSV9MRVZFTCIsImdldFNka0JpbmFyeVBhdGgiLCJiaW5hcnlOYW1lIiwiZ2V0QmluYXJ5RnJvbVNka1Jvb3QiLCJnZXRCaW5hcnlOYW1lRm9yT1MiLCJfIiwibWVtb2l6ZSIsImdldEJpbmFyeU5hbWVGb3JPU01lbW9yaXplIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiaW5jbHVkZXMiLCJwYXRoIiwiZXh0bmFtZSIsImJpbmFyaWVzIiwiZnVsbEJpbmFyeU5hbWUiLCJiaW5hcnlMb2NzIiwiZ2V0U2RrQmluYXJ5TG9jYXRpb25DYW5kaWRhdGVzIiwic2RrUm9vdCIsImJ1aWxkVG9vbHNEaXJzIiwiYnVpbGRUb29sc1ZlcnNpb24iLCJmaWx0ZXIiLCJ4IiwiYmFzZW5hbWUiLCJpc0VtcHR5IiwibG9nIiwiaW5mbyIsInB1c2giLCJmbGF0dGVuIiwibWFwIiwiZGlyIiwicmVzb2x2ZSIsImJpbmFyeUxvYyIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheSIsImdldEFuZHJvaWRCaW5hcnlQYXRoIiwiZ2V0QmluYXJ5RnJvbVBhdGgiLCJ3aGljaCIsImUiLCJnZXRDb25uZWN0ZWREZXZpY2VzIiwiZGVidWciLCJzdGRvdXQiLCJleGVjdXRhYmxlIiwiZGVmYXVsdEFyZ3MiLCJtZXNzYWdlIiwibGlzdEhlYWRlciIsInN0YXJ0aW5nSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJleGNsdWRlZExpbmVzIiwiYWxsb3dPZmZsaW5lRGV2aWNlcyIsImRldmljZXMiLCJzcGxpdCIsInRyaW0iLCJsaW5lIiwic29tZSIsInJlZHVjZSIsImFjYyIsInVkaWQiLCJzdGF0ZSIsImdldERldmljZXNXaXRoUmV0cnkiLCJ0aW1lb3V0TXMiLCJ0aW1lciIsInRpbWluZyIsIlRpbWVyIiwic3RhcnQiLCJnZXREZXZpY2VzIiwiZ2V0RHVyYXRpb24iLCJhc01pbGxpU2Vjb25kcyIsInRvRml4ZWQiLCJsZW5ndGgiLCJpZ24iLCJyZWNvbm5lY3QiLCJyZXN0YXJ0QWRiIiwidGFyZ2V0IiwiYXJncyIsImFkYkV4ZWMiLCJzdGRlcnIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwiZXhjbHVzaXZlIiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsIndhcm4iLCJkc3RQYXRoIiwid3JpdGVGaWxlIiwiYWRiRXhlY0VtdSIsImNtZCIsInZlcmlmeUVtdWxhdG9yQ29ubmVjdGVkIiwiaXNFeGVjTG9ja2VkIiwiRVhFQ19PVVRQVVRfRk9STUFUIiwiT2JqZWN0IiwiZnJlZXplIiwiU1RET1VUIiwiRlVMTCIsIm9wdHMiLCJjbG9uZURlZXAiLCJ0aW1lb3V0IiwiYWRiRXhlY1RpbWVvdXQiLCJERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQiLCJ0aW1lb3V0Q2FwTmFtZSIsIm91dHB1dEZvcm1hdCIsImFkYlJldHJpZWQiLCJleGVjRnVuYyIsImZpbmQiLCJhcmciLCJ0ZXN0IiwidXRpbCIsInF1b3RlIiwiam9pbiIsInJlcGxhY2UiLCJlcnJUZXh0IiwicCIsImNvZGUiLCJ3YWl0TXMiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaW50ZXJ2YWxNcyIsInNoZWxsIiwicHJpdmlsZWdlZCIsImNtZEFyciIsImZ1bGxDbWQiLCJpc1Jvb3QiLCJjcmVhdGVTdWJQcm9jZXNzIiwiU3ViUHJvY2VzcyIsImdldEFkYlBhdGgiLCJnZXRBZGJTZXJ2ZXJQb3J0IiwiZ2V0RW11bGF0b3JQb3J0IiwiZW11bGF0b3JQb3J0IiwicG9ydCIsImdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmciLCJlbVN0ciIsInBvcnRQYXR0ZXJuIiwicGFyc2VJbnQiLCJleGVjIiwiZ2V0Q29ubmVjdGVkRW11bGF0b3JzIiwiZW11bGF0b3JzIiwiZGV2aWNlIiwicGx1cmFsaXplIiwic2V0RW11bGF0b3JQb3J0IiwiZW1Qb3J0Iiwic2V0RGV2aWNlSWQiLCJkZXZpY2VJZCIsImN1ckRldmljZUlkIiwiYXJnc0hhc0RldmljZSIsInNwbGljZSIsInNldERldmljZSIsImRldmljZU9iaiIsImdldFJ1bm5pbmdBVkQiLCJhdmROYW1lIiwiZW11bGF0b3IiLCJydW5uaW5nQVZETmFtZSIsImV4ZWNFbXVDb25zb2xlQ29tbWFuZCIsImV4ZWNUaW1lb3V0IiwiY29ublRpbWVvdXQiLCJ0b0xvd2VyIiwiZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSIsImtpbGxBbGxFbXVsYXRvcnMiLCJraWxsRW11bGF0b3IiLCJoYXNWYWx1ZSIsImlzRW11bGF0b3JDb25uZWN0ZWQiLCJsYXVuY2hBVkQiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJsYXVuY2hUaW1lb3V0IiwicmVhZHlUaW1lb3V0IiwicmV0cnlUaW1lcyIsImVtdWxhdG9yQmluYXJ5UGF0aCIsInN1YnN0ciIsImNoZWNrQXZkRXhpc3QiLCJsYXVuY2hBcmdzIiwiaXNEZWxheUFkYkZlYXR1cmVFbmFibGVkIiwiYWxsb3dEZWxheUFkYiIsInJldmlzaW9uIiwiZ2V0RW11VmVyc2lvbkluZm8iLCJjb21wYXJlVmVyc2lvbnMiLCJnZXRFbXVJbWFnZVByb3BlcnRpZXMiLCJhcGlNYXRjaCIsInNoZWxsUGFyc2UiLCJwcm9jIiwiYXNzaWduIiwib24iLCJCb29sZWFuIiwic2lnbmFsIiwid2FpdEZvckVtdWxhdG9yUmVhZHkiLCJnZXRWZXJzaW9uIiwicmVzdWx0IiwiYmluYXJ5VmVyc2lvbk1hdGNoIiwiYmluYXJ5IiwidmVyc2lvbiIsInNlbXZlciIsImNvZXJjZSIsImJ1aWxkIiwiYnJpZGdlVmVyc2lvbk1hdGNoIiwiYnJpZGdlIiwiZXJyIiwid2FpdEZvckRldmljZSIsImFwcERldmljZVJlYWR5VGltZW91dCIsInJldHJpZXMiLCJwaW5nIiwicmVib290Iiwid2FzQWxyZWFkeVJvb3RlZCIsInJvb3QiLCJCIiwiZGVsYXkiLCJzZXREZXZpY2VQcm9wZXJ0eSIsInVucm9vdCIsImdldERldmljZVByb3BlcnR5IiwibXNnIiwiY2hhbmdlVXNlclByaXZpbGVnZXMiLCJpc0VsZXZhdGVkIiwicmV0cnlJZk9mZmxpbmUiLCJjbWRGdW5jIiwidG9Mb3dlckNhc2UiLCJpc1N1Y2Nlc3NmdWwiLCJmaWxlRXhpc3RzIiwicmVtb3RlUGF0aCIsInBhc3NGbGFnIiwiY2hlY2tDbWQiLCJscyIsImxpbmVzIiwibCIsImZpbGVTaXplIiwiZmlsZXMiLCJtYXRjaCIsImlzTmFOIiwiaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSIsImNlcnQiLCJvcGVuU3NsIiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwidG1wUm9vdCIsInRlbXBEaXIiLCJvcGVuRGlyIiwic3JjQ2VydCIsImNlcnRIYXNoIiwiZHN0Q2VydENvbnRlbnQiLCJjb25jYXQiLCJkc3RDZXJ0IiwicmltcmFmIiwiaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQiLCJ0bXBDZXJ0IiwicG9zaXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLElBQUlBLGlCQUFpQixHQUFHLEVBQXhCO0FBRUEsTUFBTUMsMEJBQTBCLEdBQUcsRUFBbkM7QUFDQSxNQUFNQyxxQkFBcUIsR0FBRyxzQkFBOUI7QUFDQSxNQUFNQyx3QkFBd0IsR0FBRyxDQUMvQiwrQkFEK0IsRUFFL0Isa0NBRitCLEVBRy9CLGlDQUgrQixDQUFqQztB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O0FBQ0EsVUFBTWpOLFlBQUc4RCxTQUFILENBQWE2SixPQUFiLEVBQXNCZixJQUF0QixDQUFOO0FBQ0EsVUFBTTtBQUFDL0wsTUFBQUE7QUFBRCxRQUFXLE1BQU0sd0JBQUtnTSxPQUFMLEVBQWMsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QixLQUE1QixFQUFtQ2MsT0FBbkMsQ0FBZCxDQUF2QjtBQUNBTixJQUFBQSxRQUFRLEdBQUd4TSxNQUFNLENBQUNZLElBQVAsRUFBWDtBQUNELEdBTEQsQ0FLRSxPQUFPbUosR0FBUCxFQUFZO0FBQ1osVUFBTSxJQUFJekssS0FBSixDQUFXLHdDQUFELEdBQ0MsMERBREQsR0FFQyxtQkFBa0J5SyxHQUFHLENBQUM1SixPQUFRLEVBRnpDLENBQU47QUFHRCxHQVRELFNBU1U7QUFDUixVQUFNaEIsWUFBR3lOLE1BQUgsQ0FBVVIsT0FBVixDQUFOO0FBQ0Q7O0FBQ0QsUUFBTXBKLE9BQU8sR0FBR25GLGNBQUtrUCxLQUFMLENBQVcvTixPQUFYLENBQW1CaEMsVUFBbkIsRUFBZ0MsR0FBRXdQLFFBQVMsSUFBM0MsQ0FBaEI7O0FBQ0E5TixrQkFBSXFCLEtBQUosQ0FBVyx3REFBdURpRCxPQUFRLEdBQTFFOztBQUNBLFNBQU8sTUFBTSxLQUFLbUksVUFBTCxDQUFnQm5JLE9BQWhCLENBQWI7QUFDRCxDQXhCRDs7ZUEwQmV0RyxpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdXRpbCwgdGVtcERpciwgdGltaW5nIH0gZnJvbSAnQGFwcGl1bS9zdXBwb3J0JztcbmltcG9ydCB7XG4gIGdldEJ1aWxkVG9vbHNEaXJzLCB0b0F2ZExvY2FsZUFyZ3MsXG4gIGdldE9wZW5Tc2xGb3JPcywgREVGQVVMVF9BREJfRVhFQ19USU1FT1VULCBnZXRTZGtSb290RnJvbUVudlxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuXG5sZXQgc3lzdGVtQ2FsbE1ldGhvZHMgPSB7fTtcblxuY29uc3QgREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMgPSA5MDtcbmNvbnN0IExJTktFUl9XQVJOSU5HX1JFR0VYUCA9IC9eV0FSTklORzogbGlua2VyLiskL207XG5jb25zdCBBREJfUkVUUllfRVJST1JfUEFUVEVSTlMgPSBbXG4gIC9wcm90b2NvbCBmYXVsdCBcXChubyBzdGF0dXNcXCkvaSxcbiAgL2Vycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmQvaSxcbiAgL2Vycm9yOiBkZXZpY2Ugc3RpbGwgY29ubmVjdGluZy9pLFxuXTtcbmNvbnN0IEJJTkFSWV9WRVJTSU9OX1BBVFRFUk4gPSAvXlZlcnNpb24gKFtcXGQuXSspLShcXGQrKS9tO1xuY29uc3QgQlJJREdFX1ZFUlNJT05fUEFUVEVSTiA9IC9eQW5kcm9pZCBEZWJ1ZyBCcmlkZ2UgdmVyc2lvbiAoW1xcZC5dKykvbTtcbmNvbnN0IENFUlRTX1JPT1QgPSAnL3N5c3RlbS9ldGMvc2VjdXJpdHkvY2FjZXJ0cyc7XG5jb25zdCBTREtfQklOQVJZX1JPT1RTID0gW1xuICAncGxhdGZvcm0tdG9vbHMnLFxuICAnZW11bGF0b3InLFxuICBbJ2NtZGxpbmUtdG9vbHMnLCAnbGF0ZXN0JywgJ2JpbiddLFxuICAndG9vbHMnLFxuICBbJ3Rvb2xzJywgJ2JpbiddLFxuICAnLicgLy8gQWxsb3cgY3VzdG9tIHNka1Jvb3QgdG8gc3BlY2lmeSBmdWxsIGZvbGRlciBwYXRoXG5dO1xuY29uc3QgTUlOX0RFTEFZX0FEQl9BUElfTEVWRUwgPSAyODtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gYXN5bmMgZnVuY3Rpb24gZ2V0U2RrQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tU2RrUm9vdChiaW5hcnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSBhcyBtZW1vdGl6ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TTWVtb3JpemUgKGJpbmFyeU5hbWUpIHtcbiAgcmV0dXJuIGdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgYmluYXJ5IG5hbWUgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBzaW1wbGUgYmluYXJ5IG5hbWUsIGZvciBleGFtcGxlICdhbmRyb2lkJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGJpbmFyeSBuYW1lIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsICdhbmRyb2lkLmJhdCcgb24gV2luZG93cy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TIChiaW5hcnlOYW1lKSB7XG4gIGlmICghc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIGJpbmFyeU5hbWU7XG4gIH1cblxuICBpZiAoWydhbmRyb2lkJywgJ2Fwa3NpZ25lcicsICdhcGthbmFseXplciddLmluY2x1ZGVzKGJpbmFyeU5hbWUpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmJhdGA7XG4gIH1cbiAgaWYgKCFwYXRoLmV4dG5hbWUoYmluYXJ5TmFtZSkpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeSBhbmQgY2FjaGVzIGl0IGludG8gYGJpbmFyaWVzYFxuICogcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgQURCIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gU2ltcGxlIG5hbWUgb2YgYSBiaW5hcnkgZmlsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuIFRoZSBtZXRob2QgdHJpZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZW51bWVyYXRlIGFsbCB0aGUga25vd24gbG9jYXRpb25zIHdoZXJlIHRoZSBiaW5hcnlcbiAqICAgICAgICAgICAgICAgICAgbWlnaHQgYmUgbG9jYXRlZCBhbmQgc3RvcHMgdGhlIHNlYXJjaCBhcyBzb29uIGFzIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgICBtYXRjaCBpcyBmb3VuZCBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSB3aXRoIGdpdmVuIG5hbWUgaXMgbm90IHByZXNlbnQgYXQgYW55XG4gKiAgICAgICAgICAgICAgICAgb2Yga25vd24gbG9jYXRpb25zIG9yIEFuZHJvaWQgU0RLIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gYXN5bmMgZnVuY3Rpb24gZ2V0QmluYXJ5RnJvbVNka1Jvb3QgKGJpbmFyeU5hbWUpIHtcbiAgaWYgKHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV0pIHtcbiAgICByZXR1cm4gdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXTtcbiAgfVxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBjb25zdCBiaW5hcnlMb2NzID0gZ2V0U2RrQmluYXJ5TG9jYXRpb25DYW5kaWRhdGVzKHRoaXMuc2RrUm9vdCwgZnVsbEJpbmFyeU5hbWUpO1xuXG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIGxldCBidWlsZFRvb2xzRGlycyA9IGF3YWl0IGdldEJ1aWxkVG9vbHNEaXJzKHRoaXMuc2RrUm9vdCk7XG4gIGlmICh0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uKSB7XG4gICAgYnVpbGRUb29sc0RpcnMgPSBidWlsZFRvb2xzRGlyc1xuICAgICAgLmZpbHRlcigoeCkgPT4gcGF0aC5iYXNlbmFtZSh4KSA9PT0gdGhpcy5idWlsZFRvb2xzVmVyc2lvbik7XG4gICAgaWYgKF8uaXNFbXB0eShidWlsZFRvb2xzRGlycykpIHtcbiAgICAgIGxvZy5pbmZvKGBGb3VuZCBubyBidWlsZCB0b29scyB3aG9zZSB2ZXJzaW9uIG1hdGNoZXMgdG8gJyR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbn0nYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBVc2luZyBidWlsZCB0b29scyBhdCAnJHtidWlsZFRvb2xzRGlyc30nYCk7XG4gICAgfVxuICB9XG4gIGJpbmFyeUxvY3MucHVzaCguLi4oXy5mbGF0dGVuKGJ1aWxkVG9vbHNEaXJzXG4gICAgLm1hcCgoZGlyKSA9PiBbXG4gICAgICBwYXRoLnJlc29sdmUoZGlyLCBmdWxsQmluYXJ5TmFtZSksXG4gICAgICBwYXRoLnJlc29sdmUoZGlyLCAnbGliJywgZnVsbEJpbmFyeU5hbWUpLFxuICAgIF0pKVxuICApKTtcblxuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgZm9yIChjb25zdCBsb2Mgb2YgYmluYXJ5TG9jcykge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMobG9jKSkge1xuICAgICAgYmluYXJ5TG9jID0gbG9jO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfLmlzTnVsbChiaW5hcnlMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluICR7SlNPTi5zdHJpbmdpZnkoYmluYXJ5TG9jcyl9LiBgICtcbiAgICAgIGBEbyB5b3UgaGF2ZSBBbmRyb2lkIEJ1aWxkIFRvb2xzICR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbiA/IGB2ICR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbn0gYCA6ICcnfWAgK1xuICAgICAgYGluc3RhbGxlZCBhdCAnJHt0aGlzLnNka1Jvb3R9Jz9gKTtcbiAgfVxuICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV0gPSBiaW5hcnlMb2M7XG4gIHJldHVybiBiaW5hcnlMb2M7XG59O1xuXG4vKipcbiAqICBSZXR1cm5zIHRoZSBBbmRyb2lkIGJpbmFyaWVzIGxvY2F0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtSb290IFRoZSBwYXRoIHRvIEFuZHJvaWQgU0RLIHJvb3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVsbEJpbmFyeU5hbWUgVGhlIG5hbWUgb2YgZnVsbCBiaW5hcnkgbmFtZS5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IFRoZSBsaXN0IG9mIFNES19CSU5BUllfUk9PVFMgcGF0aHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNka1Jvb3QgYW5kIGZ1bGxCaW5hcnlOYW1lLlxuICovXG5mdW5jdGlvbiBnZXRTZGtCaW5hcnlMb2NhdGlvbkNhbmRpZGF0ZXMgKHNka1Jvb3QsIGZ1bGxCaW5hcnlOYW1lKSB7XG4gIHJldHVybiBTREtfQklOQVJZX1JPT1RTLm1hcCgoeCkgPT5cbiAgICBwYXRoLnJlc29sdmUoc2RrUm9vdCwgLi4uKF8uaXNBcnJheSh4KSA/IHggOiBbeF0pLCBmdWxsQmluYXJ5TmFtZSkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gJ2FkYicsICdhbmRyb2lkJ1xuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS4gVGhlIG1ldGhvZCB0cmllc1xuICogICAgICAgICAgICAgICAgICB0byBlbnVtZXJhdGUgYWxsIHRoZSBrbm93biBsb2NhdGlvbnMgd2hlcmUgdGhlIGJpbmFyeVxuICogICAgICAgICAgICAgICAgICBtaWdodCBiZSBsb2NhdGVkIGFuZCBzdG9wcyB0aGUgc2VhcmNoIGFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgIG1hdGNoIGlzIGZvdW5kIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqICAgICAgICAgICAgICAgICAgZS5nLiAnL1BhdGgvVG8vQW5kcm9pZC9zZGsvcGxhdGZvcm0tdG9vbHMvYWRiJ1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBbmRyb2lkQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IGdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgY29uc3Qgc2RrUm9vdCA9IGdldFNka1Jvb3RGcm9tRW52KCk7XG4gIGNvbnN0IGJpbmFyeUxvY3MgPSBnZXRTZGtCaW5hcnlMb2NhdGlvbkNhbmRpZGF0ZXMoc2RrUm9vdCwgZnVsbEJpbmFyeU5hbWUpO1xuICBmb3IgKGNvbnN0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICByZXR1cm4gbG9jO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICcke2Z1bGxCaW5hcnlOYW1lfScgaW4gJHtKU09OLnN0cmluZ2lmeShiaW5hcnlMb2NzKX0uIGAgK1xuICAgIGBEbyB5b3UgaGF2ZSBBbmRyb2lkIEJ1aWxkIFRvb2xzIGluc3RhbGxlZCBhdCAnJHtzZGtSb290fSc/YCk7XG59XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21QYXRoIChiaW5hcnlOYW1lKSB7XG4gIGlmICh0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV07XG4gIH1cblxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IGJpbmFyeUxvYyA9IGF3YWl0IGZzLndoaWNoKGZ1bGxCaW5hcnlOYW1lKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gICAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluIFBBVEguIFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgIGBvciBBTkRST0lEX1NES19ST09UIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgY29ycmVjdCBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgY29ubmVjdGVkIGRldmljZXMnKTtcbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAnZGV2aWNlcyddKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICBjb25zdCBsaXN0SGVhZGVyID0gJ0xpc3Qgb2YgZGV2aWNlcyc7XG4gIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKGxpc3RIZWFkZXIpO1xuICBpZiAoc3RhcnRpbmdJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IHdoaWxlIHRyeWluZyB0byBnZXQgZGV2aWNlczogJHtzdGRvdXR9YCk7XG4gIH1cbiAgLy8gc2xpY2luZyBvdXRwdXQgd2UgY2FyZSBhYm91dFxuICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gIGxldCBleGNsdWRlZExpbmVzID0gW2xpc3RIZWFkZXIsICdhZGIgc2VydmVyJywgJyogZGFlbW9uJ107XG4gIGlmICghdGhpcy5hbGxvd09mZmxpbmVEZXZpY2VzKSB7XG4gICAgZXhjbHVkZWRMaW5lcy5wdXNoKCdvZmZsaW5lJyk7XG4gIH1cbiAgY29uc3QgZGV2aWNlcyA9IHN0ZG91dC5zcGxpdCgnXFxuJylcbiAgICAubWFwKF8udHJpbSlcbiAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lICYmICFleGNsdWRlZExpbmVzLnNvbWUoKHgpID0+IGxpbmUuaW5jbHVkZXMoeCkpKVxuICAgIC5yZWR1Y2UoKGFjYywgbGluZSkgPT4ge1xuICAgICAgLy8gc3RhdGUgaXMgXCJkZXZpY2VcIiwgYWZhaWNcbiAgICAgIGNvbnN0IFt1ZGlkLCBzdGF0ZV0gPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICBhY2MucHVzaCh7dWRpZCwgc3RhdGV9KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICBpZiAoXy5pc0VtcHR5KGRldmljZXMpKSB7XG4gICAgbG9nLmRlYnVnKCdObyBjb25uZWN0ZWQgZGV2aWNlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuZGVidWcoYENvbm5lY3RlZCBkZXZpY2VzOiAke0pTT04uc3RyaW5naWZ5KGRldmljZXMpfWApO1xuICB9XG4gIHJldHVybiBkZXZpY2VzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBnZXQgYXQgbGVhc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgbGlzdCBpdGVtLlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGNvbm5lY3RlZCBkZXZpY2VzIGNhbiBiZSBkZXRlY3RlZCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldERldmljZXNXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiBnZXREZXZpY2VzV2l0aFJldHJ5ICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBsb2cuZGVidWcoJ1RyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlJyk7XG4gIGNvbnN0IGdldERldmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHRpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0ZWQgQW5kcm9pZCBkZXZpY2UgaW4gJHt0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzLnRvRml4ZWQoMCl9bXMuYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbikge31cblxuICAgIGxvZy5kZWJ1ZygnQ291bGQgbm90IGZpbmQgb25saW5lIGRldmljZXMnKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgIH1cbiAgICAvLyBjb29sIGRvd25cbiAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gIH07XG4gIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG59O1xuXG4vKipcbiAqIEtpY2sgY3VycmVudCBjb25uZWN0aW9uIGZyb20gaG9zdC9kZXZpY2Ugc2lkZSBhbmQgbWFrZSBpdCByZWNvbm5lY3RcbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRhcmdldCBbb2ZmbGluZV0gT25lIG9mIHBvc3NpYmxlIHRhcmdldHMgdG8gcmVjb25uZWN0OlxuICogb2ZmbGluZSwgZGV2aWNlIG9yIG51bGxcbiAqIFByb3ZpZGluZyBgbnVsbGAgd2lsbCBjYXVzZSByZWNvbm5lY3Rpb24gdG8gaGFwcGVuIGZyb20gdGhlIGhvc3Qgc2lkZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZWl0aGVyIEFEQiB2ZXJzaW9uIGlzIHRvbyBvbGQgYW5kIGRvZXMgbm90IHN1cHBvcnQgdGhpc1xuICogY29tbWFuZCBvciB0aGVyZSB3YXMgYSBmYWlsdXJlIGR1cmluZyByZWNvbm5lY3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uIHJlY29ubmVjdCAodGFyZ2V0ID0gJ29mZmxpbmUnKSB7XG4gIGxvZy5kZWJ1ZyhgUmVjb25uZWN0aW5nIGFkYiAodGFyZ2V0ICR7dGFyZ2V0fSlgKTtcblxuICBjb25zdCBhcmdzID0gWydyZWNvbm5lY3QnXTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGFyZ3MucHVzaCh0YXJnZXQpO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVjb25uZWN0IGFkYi4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJlc3RhcnQgYWRiIHNlcnZlciwgdW5sZXNzIF90aGlzLnN1cHByZXNzS2lsbFNlcnZlcl8gcHJvcGVydHkgaXMgdHJ1ZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzdGFydEFkYiA9IGFzeW5jIGZ1bmN0aW9uIHJlc3RhcnRBZGIgKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydzdGFydC1zZXJ2ZXInXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoYEVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgYWRiIHNlcnZlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbFNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxTZXJ2ZXIgKCkge1xuICBsb2cuZGVidWcoYEtpbGxpbmcgYWRiIHNlcnZlciBvbiBwb3J0ICcke3RoaXMuYWRiUG9ydH0nYCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2tpbGwtc2VydmVyJ10sIHtcbiAgICBleGNsdXNpdmU6IHRydWUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGVsbmV0QXV0aFRva2VuICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gYWRiRXhlY0VtdSAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbmxldCBpc0V4ZWNMb2NrZWQgPSBmYWxzZTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuRVhFQ19PVVRQVVRfRk9STUFUID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNURE9VVDogJ3N0ZG91dCcsXG4gIEZVTEw6ICdmdWxsJyxcbn0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV4ZWNSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGRvdXQgVGhlIHN0ZG91dCByZWNlaXZlZCBmcm9tIGV4ZWNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGRlcnIgVGhlIHN0ZGVyciByZWNlaXZlZCBmcm9tIGV4ZWNcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGFkYiBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICBvciBhIHNpbmdsZSBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGFsc28gc2V0IHRoZSBhZGRpdGlvbmFsIGBleGNsdXNpdmVgIHBhcmFtXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRvIGB0cnVlYCB0aGF0IGFzc3VyZXMgbm8gb3RoZXIgcGFyYWxsZWwgYWRiIGNvbW1hbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBnb2luZyB0byBiZSBleGVjdXRlZCB3aGlsZSB0aGUgY3VycmVudCBvbmUgaXMgcnVubmluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHNldCB0aGUgYG91dHB1dEZvcm1hdGAgcGFyYW0gdG8gYHN0ZG91dGAgdG8gcmVjZWl2ZSBqdXN0IHRoZSBzdGRvdXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0IChkZWZhdWx0KSBvciBgZnVsbGAgdG8gcmVjZWl2ZSB0aGUgc3Rkb3V0IGFuZCBzdGRlcnIgcmVzcG9uc2UgZnJvbSBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgd2l0aCBhIHplcm8gZXhpdCBjb2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd8RXhlY1Jlc3VsdH0gLSBDb21tYW5kJ3Mgc3Rkb3V0IG9yIGFuIG9iamVjdCBjb250YWluaW5nIHN0ZG91dCBhbmQgc3RkZXJyLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGFkYkV4ZWMgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKCknKTtcbiAgfVxuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmFkYkV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2FkYkV4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjb25zdCB7b3V0cHV0Rm9ybWF0ID0gdGhpcy5FWEVDX09VVFBVVF9GT1JNQVQuU1RET1VUfSA9IG9wdHM7XG5cbiAgY21kID0gXy5pc0FycmF5KGNtZCkgPyBjbWQgOiBbY21kXTtcbiAgbGV0IGFkYlJldHJpZWQgPSBmYWxzZTtcbiAgY29uc3QgZXhlY0Z1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAuLi5jbWRdO1xuICAgICAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSBgICtcbiAgICAgICAgKGFyZ3MuZmluZCgoYXJnKSA9PiAvXFxzKy8udGVzdChhcmcpKSA/IHV0aWwucXVvdGUoYXJncykgOiBhcmdzLmpvaW4oJyAnKSkgKyBgJ2ApO1xuICAgICAgbGV0IHtzdGRvdXQsIHN0ZGVycn0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgIC8vIHNvbWV0aW1lcyBBREIgcHJpbnRzIG91dCB3ZWlyZCBzdGRvdXQgd2FybmluZ3MgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBpbmNsdWRlIGluIGFueSBvZiB0aGUgcmVzcG9uc2UgZGF0YSwgc28gbGV0J3Mgc3RyaXAgaXQgb3V0XG4gICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gb3V0cHV0Rm9ybWF0ID09PSB0aGlzLkVYRUNfT1VUUFVUX0ZPUk1BVC5GVUxMID8ge3N0ZG91dCwgc3RkZXJyfSA6IHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJUZXh0ID0gYCR7ZS5tZXNzYWdlfSwgJHtlLnN0ZG91dH0sICR7ZS5zdGRlcnJ9YDtcbiAgICAgIGlmIChBREJfUkVUUllfRVJST1JfUEFUVEVSTlMuc29tZSgocCkgPT4gcC50ZXN0KGVyclRleHQpKSkge1xuICAgICAgICBsb2cuaW5mbyhgRXJyb3Igc2VuZGluZyBjb21tYW5kLCByZWNvbm5lY3RpbmcgZGV2aWNlIGFuZCByZXRyeWluZzogJHtjbWR9YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmdldERldmljZXNXaXRoUmV0cnkoKTtcblxuICAgICAgICAvLyB0cnkgYWdhaW4gb25lIHRpbWVcbiAgICAgICAgaWYgKGFkYlJldHJpZWQpIHtcbiAgICAgICAgICBhZGJSZXRyaWVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jb2RlID09PSAwICYmIGUuc3Rkb3V0KSB7XG4gICAgICAgIHJldHVybiBlLnN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOdWxsKGUuY29kZSkpIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgIGBUcnkgdG8gaW5jcmVhc2UgdGhlICR7b3B0cy50aW1lb3V0fW1zIGFkYiBleGVjdXRpb24gdGltZW91dCByZXByZXNlbnRlZCBieSAnJHtvcHRzLnRpbWVvdXRDYXBOYW1lfScgY2FwYWJpbGl0eWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgYENvbW1hbmQgb3V0cHV0OiAke2Uuc3RkZXJyIHx8IGUuc3Rkb3V0IHx8ICc8ZW1wdHk+J31gO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGlzRXhlY0xvY2tlZCkge1xuICAgIGxvZy5kZWJ1ZygnV2FpdGluZyB1bnRpbCB0aGUgb3RoZXIgZXhjbHVzaXZlIEFEQiBjb21tYW5kIGlzIGNvbXBsZXRlZCcpO1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oKCkgPT4gIWlzRXhlY0xvY2tlZCwge1xuICAgICAgd2FpdE1zOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGludGVydmFsTXM6IDEwLFxuICAgIH0pO1xuICAgIGxvZy5kZWJ1ZygnQ29udGludWluZyB3aXRoIHRoZSBjdXJyZW50IEFEQiBjb21tYW5kJyk7XG4gIH1cbiAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XG4gICAgaXNFeGVjTG9ja2VkID0gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjRnVuYygpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvcHRzLmV4Y2x1c2l2ZSkge1xuICAgICAgaXNFeGVjTG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNoZWxsRXhlY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdGltZW91dENhcE5hbWUgW2FkYkV4ZWNUaW1lb3V0XSAtIHRoZSBuYW1lIG9mIHRoZSBjb3JyZXNwb25kaW5nIEFwcGl1bSdzIHRpbWVvdXQgY2FwYWJpbGl0eVxuICogKHVzZWQgaW4gdGhlIGVycm9yIG1lc3NhZ2VzKS5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdGltZW91dCBbYWRiRXhlY1RpbWVvdXRdIC0gY29tbWFuZCBleGVjdXRpb24gdGltZW91dC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHByaXZpbGVnZWQgW2ZhbHN5XSAtIFdoZXRoZXIgdG8gcnVuIHRoZSBnaXZlbiBjb21tYW5kIGFzIHJvb3QuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG91dHB1dEZvcm1hdCBbc3Rkb3V0XSAtIFdoZXRoZXIgcmVzcG9uc2Ugc2hvdWxkIGluY2x1ZGUgZnVsbCBleGVjIG91dHB1dCBvciBqdXN0IHN0ZG91dC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG90ZW50aWFsIHZhbHVlcyBhcmUgZnVsbCBvciBzdGRvdXQuXG4gKlxuICogQWxsIG90aGVyIHByb3BlcnRpZXMgYXJlIHRoZSBzYW1lIGFzIGZvciBgZXhlY2AgY2FsbCBmcm9tIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBjb21tYW5kIHVzaW5nIF9hZGIgc2hlbGxfIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPnxzdHJpbmd9IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzIG9yIGEgc2luZ2xlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7P1NoZWxsRXhlY09wdGlvbnN9IG9wdHMgW3t9XSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zaGVsbCA9IGFzeW5jIGZ1bmN0aW9uIHNoZWxsIChjbWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcHJpdmlsZWdlZCxcbiAgfSA9IG9wdHM7XG5cbiAgY29uc3QgY21kQXJyID0gXy5pc0FycmF5KGNtZCkgPyBjbWQgOiBbY21kXTtcbiAgY29uc3QgZnVsbENtZCA9IFsnc2hlbGwnXTtcbiAgaWYgKHByaXZpbGVnZWQpIHtcbiAgICBsb2cuaW5mbyhgJ2FkYiBzaGVsbCAke3V0aWwucXVvdGUoY21kQXJyKX0nIHJlcXVpcmVzIHJvb3QgYWNjZXNzYCk7XG4gICAgaWYgKGF3YWl0IHRoaXMuaXNSb290KCkpIHtcbiAgICAgIGxvZy5pbmZvKCdUaGUgZGV2aWNlIGFscmVhZHkgaGFkIHJvb3QgYWNjZXNzJyk7XG4gICAgICBmdWxsQ21kLnB1c2goLi4uY21kQXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsbENtZC5wdXNoKCdzdScsICdyb290JywgdXRpbC5xdW90ZShjbWRBcnIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnVsbENtZC5wdXNoKC4uLmNtZEFycik7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRoaXMuYWRiRXhlYyhmdWxsQ21kLCBvcHRzKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVTdWJQcm9jZXNzIChhcmdzID0gW10pIHtcbiAgLy8gYWRkIHRoZSBkZWZhdWx0IGFyZ3VtZW50c1xuICBhcmdzID0gWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgLi4uYXJnc107XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhZGIgcG9ydC5cbiAqIEB0b2RvIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkIHRoaXMuYWRiUG9ydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBhZGIgcG9ydCBudW1iZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiBnZXRBZGJTZXJ2ZXJQb3J0ICgpIHtcbiAgcmV0dXJuIHRoaXMuYWRiUG9ydDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBmcm9tIF9hZGIgZGV2aXZlc18gb3V0cHV0LlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEVtdWxhdG9yUG9ydCA9IGFzeW5jIGZ1bmN0aW9uIGdldEVtdWxhdG9yUG9ydCAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBydW5uaW5nIGVtdWxhdG9yIHBvcnQnKTtcbiAgaWYgKHRoaXMuZW11bGF0b3JQb3J0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW11bGF0b3JQb3J0O1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VzWzBdLnVkaWQpO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBwb3J0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGV2aWNlcyBjb25uZWN0ZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGJ5IHBhcnNpbmcgZW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVtU3RyIC0gRW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gRWl0aGVyIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBfZmFsc2VfIGlmIHBvcnQgbnVtYmVyIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgPSBmdW5jdGlvbiBnZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZEVtdWxhdG9ycyAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzJyk7XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgZW11bGF0b3JzID0gW107XG4gICAgZm9yIChsZXQgZGV2aWNlIG9mIGRldmljZXMpIHtcbiAgICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZS51ZGlkKTtcbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIGRldmljZS5wb3J0ID0gcG9ydDtcbiAgICAgICAgZW11bGF0b3JzLnB1c2goZGV2aWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGAke3V0aWwucGx1cmFsaXplKCdlbXVsYXRvcicsIGVtdWxhdG9ycy5sZW5ndGgsIHRydWUpfSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiBzZXRFbXVsYXRvclBvcnQgKGVtUG9ydCkge1xuICB0aGlzLmVtdWxhdG9yUG9ydCA9IGVtUG9ydDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpZGVudGlmaWVyIG9mIHRoZSBjdXJyZW50IGRldmljZSAoX3RoaXMuY3VyRGV2aWNlSWRfKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gLSBUaGUgZGV2aWNlIGlkZW50aWZpZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZUlkID0gZnVuY3Rpb24gc2V0RGV2aWNlSWQgKGRldmljZUlkKSB7XG4gIGxvZy5kZWJ1ZyhgU2V0dGluZyBkZXZpY2UgaWQgdG8gJHtkZXZpY2VJZH1gKTtcbiAgdGhpcy5jdXJEZXZpY2VJZCA9IGRldmljZUlkO1xuICBsZXQgYXJnc0hhc0RldmljZSA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5pbmRleE9mKCctcycpO1xuICBpZiAoYXJnc0hhc0RldmljZSAhPT0gLTEpIHtcbiAgICAvLyByZW1vdmUgdGhlIG9sZCBkZXZpY2UgaWQgZnJvbSB0aGUgYXJndW1lbnRzXG4gICAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnNwbGljZShhcmdzSGFzRGV2aWNlLCAyKTtcbiAgfVxuICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MucHVzaCgnLXMnLCBkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGhlIGN1cnJlbnQgZGV2aWNlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlT2JqIC0gVGhlIGRldmljZSBvYmplY3QgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2UgPSBmdW5jdGlvbiBzZXREZXZpY2UgKGRldmljZU9iaikge1xuICBsZXQgZGV2aWNlSWQgPSBkZXZpY2VPYmoudWRpZDtcbiAgbGV0IGVtUG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VJZCk7XG4gIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtUG9ydCk7XG4gIHRoaXMuc2V0RGV2aWNlSWQoZGV2aWNlSWQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICogISEhIFRoaXMgbWV0aG9kIGhhcyBhIHNpZGUgZWZmZWN0IC0gaXQgaW1wbGljaXRseSBjaGFuZ2VzIHRoZVxuICogYGRldmljZUlkYCAob25seSBpZiBBVkQgd2l0aCBhIG1hdGNoaW5nIG5hbWUgaXMgZm91bmQpXG4gKiBhbmQgYGVtdWxhdG9yUG9ydGAgaW5zdGFuY2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiBnZXRSdW5uaW5nQVZEIChhdmROYW1lKSB7XG4gIGxvZy5kZWJ1ZyhgVHJ5aW5nIHRvIGZpbmQgJyR7YXZkTmFtZX0nIGVtdWxhdG9yYCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZW11bGF0b3JzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMoKTtcbiAgICBmb3IgKGNvbnN0IGVtdWxhdG9yIG9mIGVtdWxhdG9ycykge1xuICAgICAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW11bGF0b3IucG9ydCk7XG4gICAgICBjb25zdCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuZXhlY0VtdUNvbnNvbGVDb21tYW5kKFsnYXZkJywgJ25hbWUnXSwge1xuICAgICAgICBwb3J0OiBlbXVsYXRvci5wb3J0LFxuICAgICAgICBleGVjVGltZW91dDogNTAwMCxcbiAgICAgICAgY29ublRpbWVvdXQ6IDEwMDAsXG4gICAgICB9KTtcbiAgICAgIGlmIChfLnRvTG93ZXIoYXZkTmFtZSkgPT09IF8udG9Mb3dlcihydW5uaW5nQVZETmFtZS50cmltKCkpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgZW11bGF0b3IgJyR7YXZkTmFtZX0nIG9uIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJyR7YXZkTmFtZX0nIG5vdCBydW5uaW5nYCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZELiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB3YWl0IHVudGlsIGF0IGxlYXN0IG9uZSBydW5uaW5nIEFWRCBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGRldGVjdGVkLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGRldmljZSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gdGhlIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiBnZXRSdW5uaW5nQVZEV2l0aFJldHJ5IChhdmROYW1lLCB0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZS5yZXBsYWNlKCdAJywgJycpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGUubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDEwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZEIHdpdGggcmV0cnkuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaHV0ZG93biBhbGwgcnVubmluZyBlbXVsYXRvcnMgYnkga2lsbGluZyB0aGVpciBwcm9jZXNzZXMuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGtpbGxpbmcgdG9vbCByZXR1cm5lZCBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxFbXVsYXRvcnMgKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiBraWxsRW11bGF0b3IgKGF2ZE5hbWUgPSBudWxsLCB0aW1lb3V0ID0gNjAwMDApIHtcbiAgaWYgKHV0aWwuaGFzVmFsdWUoYXZkTmFtZSkpIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKTtcbiAgICBpZiAoIWRldmljZSkge1xuICAgICAgbG9nLmluZm8oYE5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIFNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8ga2lsbGluZyB0aGUgY3VycmVudCBhdmRcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nYCk7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKGBFbXVsYXRvciB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9JyBub3QgY29ubmVjdGVkLiBTa2lwcGluZyBraWxsIHN0ZXBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXR9bXMgdW50aWwgdGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIGtpbGxlZGApO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaGFzVmFsdWUoYXZkTmFtZSlcbiAgICAgICAgICA/ICFhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSlcbiAgICAgICAgICA6ICFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXQsXG4gICAgICBpbnRlcnZhbE1zOiAyMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMgc3RpbGwgcnVubmluZyBhZnRlciBiZWluZyBraWxsZWQgJHt0aW1lb3V0fW1zIGFnb2ApO1xuICB9XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkga2lsbGVkIHRoZSAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBlbXVsYXRvcmApO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXZkTGF1bmNoT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gYXJncyBBZGRpdGlvbmFsIGVtdWxhdG9yIGNvbW1hbmQgbGluZSBhcmd1bWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbnYgQWRkaXRpb25hbCBlbXVsYXRvciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSBFbXVsYXRvciBzeXN0ZW0gbGFuZ3VhZ2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb3VudHJ5IEVtdWxhdG9yIHN5c3RlbSBjb3VudHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF1bmNoVGltZW91dCBbNjAwMDBdIEVtdWxhdG9yIHN0YXJ0dXAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFkeVRpbWVvdXQgWzYwMDAwXSBUaGUgbWF4aW11bSBwZXJpb2Qgb2YgdGltZSB0byB3YWl0IHVudGlsIEVtdWxhdG9yXG4gKiBpcyByZWFkeSBmb3IgdXNhZ2UgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmV0cnlUaW1lcyBbMV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YXJ0dXAgcmV0cmllc1xuICovXG5cbi8qKlxuICogU3RhcnQgYW4gZW11bGF0b3Igd2l0aCBnaXZlbiBwYXJhbWV0ZXJzIGFuZCB3YWl0IHVudGlsIGl0IGlzIGZ1bGx5IHN0YXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBhbiBleGlzdGluZyBlbXVsYXRvci5cbiAqIEBwYXJhbSB7P0F2ZExhdW5jaE9wdGlvbnN9IG9wdHNcbiAqIEByZXR1cm5zIHtTdWJQcm9jZXNzfSBFbXVsYXRvciBzdWJwcm9jZXNzIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gbGF1bmNoQVZEIChhdmROYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGFyZ3MgPSBbXSxcbiAgICBlbnYgPSB7fSxcbiAgICBsYW5ndWFnZSxcbiAgICBjb3VudHJ5LFxuICAgIGxhdW5jaFRpbWVvdXQgPSA2MDAwMCxcbiAgICByZWFkeVRpbWVvdXQgPSA2MDAwMCxcbiAgICByZXRyeVRpbWVzID0gMSxcbiAgfSA9IG9wdHM7XG4gIGxvZy5kZWJ1ZyhgTGF1bmNoaW5nIEVtdWxhdG9yIHdpdGggQVZEICR7YXZkTmFtZX0sIGxhdW5jaFRpbWVvdXQgYCArXG4gICAgICAgICAgICBgJHtsYXVuY2hUaW1lb3V0fW1zIGFuZCByZWFkeVRpbWVvdXQgJHtyZWFkeVRpbWVvdXR9bXNgKTtcbiAgY29uc3QgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcblxuICBjb25zdCBsYXVuY2hBcmdzID0gWyctYXZkJywgYXZkTmFtZV07XG4gIGxhdW5jaEFyZ3MucHVzaCguLi4odG9BdmRMb2NhbGVBcmdzKGxhbmd1YWdlLCBjb3VudHJ5KSkpO1xuXG4gIGxldCBpc0RlbGF5QWRiRmVhdHVyZUVuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMuYWxsb3dEZWxheUFkYikge1xuICAgIGNvbnN0IHtyZXZpc2lvbn0gPSBhd2FpdCB0aGlzLmdldEVtdVZlcnNpb25JbmZvKCk7XG4gICAgaWYgKHJldmlzaW9uICYmIHV0aWwuY29tcGFyZVZlcnNpb25zKHJldmlzaW9uLCAnPj0nLCAnMjkuMC43JykpIHtcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZHN0dWRpby5nb29nbGVibG9nLmNvbS8yMDE5LzA1L2VtdWxhdG9yLTI5MDctY2FuYXJ5Lmh0bWxcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHt0YXJnZXR9ID0gYXdhaXQgdGhpcy5nZXRFbXVJbWFnZVByb3BlcnRpZXMoYXZkTmFtZSk7XG4gICAgICAgIGNvbnN0IGFwaU1hdGNoID0gL1xcZCsvLmV4ZWModGFyZ2V0KTtcbiAgICAgICAgLy8gaHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvMTQyNTMzMzU1XG4gICAgICAgIGlmIChhcGlNYXRjaCAmJiBwYXJzZUludChhcGlNYXRjaFswXSwgMTApID49IE1JTl9ERUxBWV9BREJfQVBJX0xFVkVMKSB7XG4gICAgICAgICAgbGF1bmNoQXJncy5wdXNoKCctZGVsYXktYWRiJyk7XG4gICAgICAgICAgaXNEZWxheUFkYkZlYXR1cmVFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhY3R1YWwgaW1hZ2UgQVBJIHZlcnNpb24gaXMgYmVsb3cgJHtNSU5fREVMQVlfQURCX0FQSV9MRVZFTH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuaW5mbyhgVGhlIC1kZWxheS1hZGIgZW11bGF0b3Igc3RhcnR1cCBkZXRlY3Rpb24gZmVhdHVyZSB3aWxsIG5vdCBiZSBlbmFibGVkLiBgICtcbiAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2cuaW5mbygnVGhlIC1kZWxheS1hZGIgZW11bGF0b3Igc3RhcnR1cCBkZXRlY3Rpb24gZmVhdHVyZSBoYXMgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkJyk7XG4gIH1cblxuICBpZiAoIV8uaXNFbXB0eShhcmdzKSkge1xuICAgIGxhdW5jaEFyZ3MucHVzaCguLi4oXy5pc0FycmF5KGFyZ3MpID8gYXJncyA6IHV0aWwuc2hlbGxQYXJzZShgJHthcmdzfWApKSk7XG4gIH1cblxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke3V0aWwucXVvdGUobGF1bmNoQXJncyl9YCk7XG4gIGlmICghXy5pc0VtcHR5KGVudikpIHtcbiAgICBsb2cuZGVidWcoYEN1c3RvbWl6ZWQgZW11bGF0b3IgZW52aXJvbm1lbnQ6ICR7SlNPTi5zdHJpbmdpZnkoZW52KX1gKTtcbiAgfVxuICBjb25zdCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZW11bGF0b3JCaW5hcnlQYXRoLCBsYXVuY2hBcmdzLCB7XG4gICAgZW52OiBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudiwgZW52KSxcbiAgfSk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGxhdW5jaFRpbWVvdXQpKTtcbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGRldmljZUlkIGFscmVhZHkgYXNzaWduZWRcbiAgaWYgKGlzRGVsYXlBZGJGZWF0dXJlRW5hYmxlZCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWyd3YWl0LWZvci1kZXZpY2UnXSwge3RpbWVvdXQ6IHJlYWR5VGltZW91dH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7YXZkTmFtZX0nIEVtdWxhdG9yIGhhcyBmYWlsZWQgdG8gYm9vdDogJHtlLnN0ZGVyciB8fCBlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckVtdWxhdG9yUmVhZHkocmVhZHlUaW1lb3V0KTtcbiAgfVxuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQmluYXJ5VmVyc2lvblxuICogQHByb3BlcnR5IHtTZW1WZXJ9IHZlcnNpb24gLSBUaGUgQURCIGJpbmFyeSB2ZXJzaW9uIG51bWJlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJ1aWxkIC0gVGhlIEFEQiBiaW5hcnkgYnVpbGQgbnVtYmVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCcmlkZ2VWZXJzaW9uXG4gKiBAcHJvcGVydHkge1NlbVZlcn0gdmVyc2lvbiAtIFRoZSBBbmRyb2lkIERlYnVnIEJyaWRnZSB2ZXJzaW9uIG51bWJlclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmVyc2lvblxuICogQHByb3BlcnR5IHs/QmluYXJ5VmVyc2lvbn0gYmluYXJ5IFRoaXMgdmVyc2lvbiBudW1iZXIgbWlnaHQgbm90IGJlXG4gKiBiZSBwcmVzZW50IGZvciBvbGRlciBBREIgcmVsZWFzZXMuXG4gKiBAcHJvcGVydHkge0JyaWRnZVZlcnNpb259IGJyaWRnZVxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7VmVyc2lvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBpcyBub3QgcG9zc2libGUgdG8gcGFyc2UgYWRiIGJpbmFyeSB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKCkge1xuICBsZXQgc3Rkb3V0O1xuICB0cnkge1xuICAgIHN0ZG91dCA9IGF3YWl0IHRoaXMuYWRiRXhlYygndmVyc2lvbicpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGFkYiB2ZXJzaW9uOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBiaW5hcnlWZXJzaW9uTWF0Y2ggPSBCSU5BUllfVkVSU0lPTl9QQVRURVJOLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGJpbmFyeVZlcnNpb25NYXRjaCkge1xuICAgIHJlc3VsdC5iaW5hcnkgPSB7XG4gICAgICB2ZXJzaW9uOiBzZW12ZXIuY29lcmNlKGJpbmFyeVZlcnNpb25NYXRjaFsxXSksXG4gICAgICBidWlsZDogcGFyc2VJbnQoYmluYXJ5VmVyc2lvbk1hdGNoWzJdLCAxMCksXG4gICAgfTtcbiAgfVxuICBjb25zdCBicmlkZ2VWZXJzaW9uTWF0Y2ggPSBCUklER0VfVkVSU0lPTl9QQVRURVJOLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGJyaWRnZVZlcnNpb25NYXRjaCkge1xuICAgIHJlc3VsdC5icmlkZ2UgPSB7XG4gICAgICB2ZXJzaW9uOiBzZW12ZXIuY29lcmNlKGJyaWRnZVZlcnNpb25NYXRjaFsxXSksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZW11bGF0b3IgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JFbXVsYXRvclJlYWR5ID0gYXN5bmMgZnVuY3Rpb24gd2FpdEZvckVtdWxhdG9yUmVhZHkgKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnNoZWxsKFsnZ2V0cHJvcCcsICdpbml0LnN2Yy5ib290YW5pbSddKSkuaW5jbHVkZXMoJ3N0b3BwZWQnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHBhY2thZ2UgbWFuYWdlciBzZXJ2aWNlIG1pZ2h0IHN0aWxsIGJlaW5nIGluaXRpYWxpemVkXG4gICAgICAgIC8vIG9uIHNsb3cgc3lzdGVtcyBldmVuIGFmdGVyIGVtdWxhdG9yIGJvb3RpbmcgaXMgY29tcGxldGVkLlxuICAgICAgICAvLyBUaGUgdXN1YWwgb3V0cHV0IG9mIGBwbSBnZXQtaW5zdGFsbC1sb2NhdGlvbmAgY29tbWFuZCBsb29rcyBsaWtlIGAwW2F1dG9dYFxuICAgICAgICByZXR1cm4gL1xcZCtcXFtcXHcrXFxdLy50ZXN0KGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdnZXQtaW5zdGFsbC1sb2NhdGlvbiddKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBXYWl0aW5nIGZvciBlbXVsYXRvciBzdGFydHVwLiBJbnRlcm1lZGlhdGUgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDMwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gJHt0aW1lb3V0TXN9bXNgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0IFszMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXZpY2UgKGFwcERldmljZVJlYWR5VGltZW91dCA9IDMwKSB7XG4gIHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0O1xuICBjb25zdCByZXRyaWVzID0gMztcbiAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0LCAxMCkgKiAxMDAwIC8gcmV0cmllcztcbiAgYXdhaXQgcmV0cnkocmV0cmllcywgYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoJ3dhaXQtZm9yLWRldmljZScsIHt0aW1lb3V0fSk7XG4gICAgICBhd2FpdCB0aGlzLnBpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHJlYm9vdCAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIC8vIEdldCByb290IGFjY2VzcyBzbyB3ZSBjYW4gcnVuIHRoZSBuZXh0IHNoZWxsIGNvbW1hbmRzIHdoaWNoIHJlcXVpcmUgcm9vdCBhY2Nlc3NcbiAgY29uc3QgeyB3YXNBbHJlYWR5Um9vdGVkIH0gPSBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgdHJ5IHtcbiAgICAvLyBTdG9wIGFuZCByZS1zdGFydCB0aGUgZGV2aWNlXG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgYXdhaXQgQi5kZWxheSgyMDAwKTsgLy8gbGV0IHRoZSBlbXUgZmluaXNoIHN0b3BwaW5nO1xuICAgIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDAsIHtcbiAgICAgIHByaXZpbGVnZWQ6IGZhbHNlIC8vIG5vIG5lZWQgdG8gc2V0IHByaXZpbGVnZWQgdHJ1ZSBiZWNhdXNlIGRldmljZSBhbHJlYWR5IHJvb3RlZFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdGFydCddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IHttZXNzYWdlfSA9IGU7XG5cbiAgICAvLyBwcm92aWRlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlIGlmIHRoZSByZWFzb24gcmVib290IGZhaWxlZCB3YXMgYmVjYXVzZSBBREIgY291bGRuJ3QgZ2FpbiByb290IGFjY2Vzc1xuICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdtdXN0IGJlIHJvb3QnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVib290IGRldmljZS4gUmVib290aW5nIHJlcXVpcmVzIHJvb3QgYWNjZXNzIGFuZCBgICtcbiAgICAgICAgYGF0dGVtcHQgdG8gZ2V0IHJvb3QgYWNjZXNzIG9uIGRldmljZSBmYWlsZWQgd2l0aCBlcnJvcjogJyR7bWVzc2FnZX0nYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmV0dXJuIHJvb3Qgc3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlXG4gICAgaWYgKCF3YXNBbHJlYWR5Um9vdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnVucm9vdCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoKGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcpKSA9PT0gJzEnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHN0YWNrIHRyYWNlLCBzbyBubyBsb2cuZXJyb3JBbmRUaHJvd1xuICAgIGNvbnN0IG1zZyA9IGBSZWJvb3QgaXMgbm90IGNvbXBsZXRlZCBhZnRlciAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMudG9GaXhlZCgwKX1tc2A7XG4gICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSByb290UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3VjY2Vzc2Z1bCBUcnVlIGlmIHRoZSBjYWxsIHRvIHJvb3QvdW5yb290IHdhcyBzdWNjZXNzZnVsXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdhc0FscmVhZHlSb290ZWQgVHJ1ZSBpZiB0aGUgZGV2aWNlIHdhcyBhbHJlYWR5IHJvb3RlZFxuICovXG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgcm9vdCBwcml2aWxlZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBpc0VsZXZhdGVkIC0gU2hvdWxkIHdlIGVsZXZhdGUgdG8gdG8gcm9vdCBvciB1bnJvb3Q/IChkZWZhdWx0IHRydWUpXG4gKiBAcmV0dXJuIHtyb290UmVzdWx0fVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGFuZ2VVc2VyUHJpdmlsZWdlcyA9IGFzeW5jIGZ1bmN0aW9uIGNoYW5nZVVzZXJQcml2aWxlZ2VzIChpc0VsZXZhdGVkKSB7XG4gIGNvbnN0IGNtZCA9IGlzRWxldmF0ZWQgPyAncm9vdCcgOiAndW5yb290JztcblxuICBjb25zdCByZXRyeUlmT2ZmbGluZSA9IGFzeW5jIChjbWRGdW5jKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjbWRGdW5jKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBDaGVjayB0aGUgb3V0cHV0IG9mIHRoZSBzdGRFcnIgdG8gc2VlIGlmIHRoZXJlJ3MgYW55IGNsdWVzIHRoYXQgc2hvdyB0aGF0IHRoZSBkZXZpY2Ugd2VudCBvZmZsaW5lXG4gICAgICAvLyBhbmQgaWYgaXQgZGlkIGdvIG9mZmxpbmUsIHJlc3RhcnQgQURCXG4gICAgICBpZiAoWydjbG9zZWQnLCAnZGV2aWNlIG9mZmxpbmUnLCAndGltZW91dCBleHBpcmVkJ11cbiAgICAgICAgICAuc29tZSgoeCkgPT4gKGVyci5zdGRlcnIgfHwgJycpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoeCkpKSB7XG4gICAgICAgIGxvZy53YXJuKGBBdHRlbXB0IHRvICR7Y21kfSBjYXVzZWQgQURCIHRvIHRoaW5rIHRoZSBkZXZpY2Ugd2VudCBvZmZsaW5lYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNtZEZ1bmMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gSWYgaXQncyBhbHJlYWR5IHJvb3RlZCwgb3VyIGpvYiBpcyBkb25lLiBObyBuZWVkIHRvIHJvb3QgaXQgYWdhaW4uXG4gIGNvbnN0IGlzUm9vdCA9IGF3YWl0IHJldHJ5SWZPZmZsaW5lKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuaXNSb290KCkpO1xuICBpZiAoKGlzUm9vdCAmJiBpc0VsZXZhdGVkKSB8fCAoIWlzUm9vdCAmJiAhaXNFbGV2YXRlZCkpIHtcbiAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogdHJ1ZSwgd2FzQWxyZWFkeVJvb3RlZDogaXNSb290fTtcbiAgfVxuXG4gIGxldCB3YXNBbHJlYWR5Um9vdGVkID0gaXNSb290O1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgcmV0cnlJZk9mZmxpbmUoYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKFtjbWRdKSk7XG4gICAgbG9nLmRlYnVnKHN0ZG91dCk7XG5cbiAgICAvLyBvbiByZWFsIGRldmljZXMgaW4gc29tZSBzaXR1YXRpb25zIHdlIGdldCBhbiBlcnJvciBpbiB0aGUgc3Rkb3V0XG4gICAgaWYgKHN0ZG91dCkge1xuICAgICAgaWYgKHN0ZG91dC5pbmNsdWRlcygnYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSkge1xuICAgICAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogZmFsc2UsIHdhc0FscmVhZHlSb290ZWR9O1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIGRldmljZSB3YXMgYWxyZWFkeSByb290ZWQsIHJldHVybiB0aGF0IGluIHRoZSByZXN1bHRcbiAgICAgIGlmIChzdGRvdXQuaW5jbHVkZXMoJ2FscmVhZHkgcnVubmluZyBhcyByb290JykpIHtcbiAgICAgICAgd2FzQWxyZWFkeVJvb3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiB0cnVlLCB3YXNBbHJlYWR5Um9vdGVkfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3Qge3N0ZGVyciA9ICcnLCBtZXNzYWdlfSA9IGVycjtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvICR7Y21kfSBhZGIgZGFlbW9uLiBPcmlnaW5hbCBlcnJvcjogJyR7bWVzc2FnZX0nLiBTdGRlcnI6ICcke3N0ZGVycn0nLiBDb250aW51aW5nLmApO1xuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiBmYWxzZSwgd2FzQWxyZWFkeVJvb3RlZH07XG4gIH1cbn07XG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgdG8gcm9vdCBtb2RlXG4gKiBAcmV0dXJuIHtyb290UmVzdWx0fVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gcm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKHRydWUpO1xufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge3Jvb3RSZXN1bHR9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHVucm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBpcyByb290XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyByb290XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGlkZW50aWZ5aW5nXG4gKiB0aGUgdXNlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNSb290ID0gYXN5bmMgZnVuY3Rpb24gaXNSb290ICgpIHtcbiAgcmV0dXJuIChhd2FpdCB0aGlzLnNoZWxsKFsnd2hvYW1pJ10pKS50cmltKCkgPT09ICdyb290Jztcbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSByZW1vdGUgcGF0aCBleGlzdHMgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHZlcmlmeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzIChyZW1vdGVQYXRoKSB7XG4gIGNvbnN0IHBhc3NGbGFnID0gJ19fUEFTU19fJztcbiAgY29uc3QgY2hlY2tDbWQgPSBgWyAtZSAnJHtyZW1vdGVQYXRoLnJlcGxhY2UoLycvZywgYFxcXFwnYCl9JyBdICYmIGVjaG8gJHtwYXNzRmxhZ31gO1xuICB0cnkge1xuICAgIHJldHVybiBfLmluY2x1ZGVzKGF3YWl0IHRoaXMuc2hlbGwoW2NoZWNrQ21kXSksIHBhc3NGbGFnKTtcbiAgfSBjYXRjaCAoaWduKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gbHMgKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoJ05vIHN1Y2ggZmlsZScpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpY3VsYXIgZmlsZSBsb2NhdGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB0aGUgZmlsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBzaXplIGluIGJ5dGVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIGZpbGVTaXplIChyZW1vdGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC84XG4gICAgY29uc3QgbWF0Y2ggPSAvW3J3eHNTdFRcXC0rXXsxMH1bXFxzXFxkXSpcXHNbXlxcc10rXFxzK1teXFxzXStcXHMrKFxcZCspLy5leGVjKGZpbGVzWzBdKTtcbiAgICBpZiAoIW1hdGNoIHx8IF8uaXNOYU4ocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpemUgZnJvbSBsaXN0IG91dHB1dDogJyR7ZmlsZXNbMF19J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGZpbGUgc2l6ZSBmb3IgJyR7cmVtb3RlUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbGxzIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBvbiBhIHJvb3RlZCByZWFsIGRldmljZSBvclxuICogYW4gZW11bGF0b3IuIFRoZSBlbXVsYXRvciBtdXN0IGJlIGV4ZWN1dGVkIHdpdGggYC13cml0YWJsZS1zeXN0ZW1gXG4gKiBjb21tYW5kIGxpbmUgb3B0aW9uIGFuZCBhZGIgZGFlbW9uIHNob3VsZCBiZSBydW5uaW5nIGluIHJvb3RcbiAqIG1vZGUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmsgcHJvcGVybHkuIFRoZSBtZXRob2QgYWxzbyByZXF1aXJlc1xuICogb3BlbnNzbCB0b29sIHRvIGJlIGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtLlxuICogUmVhZCBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTA5NjRcbiAqIGZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0b3BpY1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaW5zdGFsbGluZyB0aGUgY2VydGlmaWNhdGVcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxNaXRtQ2VydGlmaWNhdGUgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShzcmNDZXJ0LCBjZXJ0KTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgc3JjQ2VydF0pO1xuICAgIGNvbnN0IGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgICBsb2cuZGVidWcoYEdvdCBjZXJ0aWZpY2F0ZSBoYXNoOiAke2NlcnRIYXNofWApO1xuICAgIGxvZy5kZWJ1ZygnUHJlcGFyaW5nIGNlcnRpZmljYXRlIGNvbnRlbnQnKTtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctaW4nLCBzcmNDZXJ0XSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGxldCBkc3RDZXJ0Q29udGVudCA9IHN0ZG91dDtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsXG4gICAgICAnLWluJywgc3JjQ2VydCxcbiAgICAgICctdGV4dCcsXG4gICAgICAnLWZpbmdlcnByaW50JyxcbiAgICAgICctbm9vdXQnXSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGRzdENlcnRDb250ZW50ID0gQnVmZmVyLmNvbmNhdChbZHN0Q2VydENvbnRlbnQsIHN0ZG91dF0pO1xuICAgIGNvbnN0IGRzdENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0Q2VydCwgZHN0Q2VydENvbnRlbnQpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIGluIHJ3IG1vZGUnKTtcbiAgICAvLyBTb21ldGltZXMgZW11bGF0b3IgcmVib290IGlzIHN0aWxsIG5vdCBmdWxseSBmaW5pc2hlZCBvbiB0aGlzIHN0YWdlLCBzbyByZXRyeVxuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoNSwgMjAwMCwgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKSk7XG4gICAgbG9nLmRlYnVnKGBVcGxvYWRpbmcgdGhlIGdlbmVyYXRlZCBjZXJ0aWZpY2F0ZSBmcm9tICcke2RzdENlcnR9JyB0byAnJHtDRVJUU19ST09UfSdgKTtcbiAgICBhd2FpdCB0aGlzLnB1c2goZHN0Q2VydCwgQ0VSVFNfUk9PVCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gdG8gY29uZmlybSBjaGFuZ2VzJyk7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5qZWN0IHRoZSBjdXN0b20gY2VydGlmaWNhdGUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHJvb3QgcGVybWlzc2lvbnMgb24gdGhlIGRldmljZT8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIHJvb3QgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgb24gdGhlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNoZWNraW5nIHRoZSBjZXJ0aWZpY2F0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkID0gYXN5bmMgZnVuY3Rpb24gaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGxldCBjZXJ0SGFzaDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0bXBDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRtcENlcnQsIGNlcnQpO1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHRtcENlcnRdKTtcbiAgICBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJldHJpZXZlIHRoZSBjZXJ0aWZpY2F0ZSBoYXNoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucG9zaXgucmVzb2x2ZShDRVJUU19ST09ULCBgJHtjZXJ0SGFzaH0uMGApO1xuICBsb2cuZGVidWcoYENoZWNraW5nIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBhdCAnJHtkc3RQYXRofSdgKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhkc3RQYXRoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5c3RlbUNhbGxNZXRob2RzO1xuZXhwb3J0IHsgREVGQVVMVF9BREJfRVhFQ19USU1FT1VULCBnZXRBbmRyb2lkQmluYXJ5UGF0aCB9O1xuIl0sImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
